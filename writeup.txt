Xin Huang <xyh1@rice.edu>
Leo Meister <lpm2@rice.edu>
COMP 321 Project 5: Malloc Dynamic Memory Allocator
4/4/15
Slip days: We used and requested 3 slip days.


DESCRIPTION

<insert a brief description of your solution (i.e., a short synopsis
of what the application does from the persepective of someone who
would use it).>

Our mm.c program essentially performs 3 operations: it dynamically allocates, frees, and reallocates memory. The 'mm_malloc' function takes the size of a memory block (in bytes) required by the user as an input and returns a pointer to a memory block of the size requested of usable consecutive bytes. The 'mm_free' function takes as an input a pointer in memory and frees the block it points to, allowing it to be used again for allocation at some later point. The 'mm_realloc' function takes as an input a pointer to an allocated block of memory and a new size and returns a new pointer to a block of usable consecutive bytes of the new size. It then moves the data from the previously used memory block into the new memory block.


DESIGN

<insert a detailed description of any appropriate design decisions you
made, such as data structures, algorithms, etc.>

We implemented a dynamic memory allocator using a segmented explicit free lists. To do so, we

We created four of our own helper functions: they were find_block_list, insert_block, delete_block, and get_list_index. The find_block_list function is used in finding a fit to find a block in a given bin that is greater than or equal to the size of the block requested. The insert_block function inserts the block into the appropriate bin. The delete_block function removes the block from the appropriate bin. The get_list_index function returns the index of the bin corresponding to the size of the given block.

We settled on using 15 lists (bins), where each bin was responsible for blocks of size up to 128 bytes greater than the previous bin [rephrase]. We chose these values by testing which ones produced the greatest total combination of utilization and throughput. To reduce the number of calls to extend heap, we increased our chunk size from 4096 to 4104.


TESTING STRATEGY

As we were developing malloc, we included print statements at the start and end of each function and checkheap calls at the end of each function in order to determine what errors were causing the code to segfault and where these errors were occurring.

We wrote our checkheap function to check that every block in our free lists were actually free, that every free block was in a free list, and that only blocks of the appropriate size were being added to the appropriate bins, in addition to the provided checks for the prologue and epilogue. 

By passing these checks, we confirmed that our implementation of the segregated lists worked at the very least. From there we tweaked the parameters for the segregated lists (number of lists, byte-range for each list) and code to improve performance. We deemed these checks to be sufficient because passing these checks and tweaking our parameters, we were able to get decent throughput and utilisation, even though we were not able to maximize them.

In addition to the checks we added, we split the provided prologue and epilogue checks to check whether the size and allocated bit were correct separately, since our code produced an invalid epilogue header early on in development.


	/* Invariance Checks:all blocks in free list actually free
	 * 		     all free blocks in free list
	 *		     free blocks escaping coalescing
	 *		free list pointers point to valid free blocks
	 *		do any allocated blocks overlap
	 *		do pointers in heap block point to valid heap addr
	 *		...
	 */

<insert a detailed description of your testing strategy: at a minimum
you should explain how you tested your code and why that testing was
sufficient.>
