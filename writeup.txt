Xin Huang <xyh1@rice.edu>
Leo Meister <lpm2@rice.edu>
COMP 321 Project 5: Malloc Dynamic Memory Allocator
4/4/15
Slip days: We used and requested 3 slip days.


DESCRIPTION

Our mm.c program essentially performs 3 operations: it dynamically allocates, frees, and reallocates memory. The 'mm_malloc' function takes the size of a memory block (in bytes) required by the user as an input and returns a pointer to a memory block of usable consecutive bytes of the size requested. The 'mm_free' function takes as an input a pointer to the heap and frees the block it points to, allowing the block to be used again for allocation at some later point. The 'mm_realloc' function takes as an input a pointer to an allocated block of memory and a new size. It returns a pointer to a block of usable consecutive bytes of the new size. It then moves the data from the previously used memory block into the new memory block.


DESIGN

We implemented a dynamic memory allocator using a segmented explicit free list approach. To do so, we created a node structure for a doubly linked list containing pointers to the next and previous nodes. Each node list acted as a single explicit free list. To segregate our bins (multiple explicit free lists), we had a pointer to a list (denoted by a pointer) of the header nodes for each list.

We created four of our own helper functions: they were find_block_list, insert_block, delete_block, and get_list_index. The find_block_list function is used to find a block in a given bin that is greater than or equal to the size of the block requested; it is called in find fit. The insert_block function inserts the given block into the appropriate bin in a last-in-first-out (LIFO) manner. The delete_block function removes the block from its bin. The get_list_index function returns the index of the bin corresponding to the size of the given block.

With these data structures and functionality in place, we were able to create a segmented explicit free list-based dynamic memory allocator.

There were two parameters that needed to be determined for our segmented free lists, the number of free lists (bins) and the range of values for each bin. We settled on using 15 lists (bins), where each bin was responsible for a range of 128 bytes. We chose these values by testing which ones produced the greatest total combination of utilization and throughput; we tested the number of bins ranging from 1 to 30 as well as 50 and 100, and we tested the bin size at powers of 2 from 16 to 256. To reduce the number of calls to extend heap, we increased our chunk size from 4096 to 4104.

Another design decision was to coalesce after freeing. We also decided to split free blocks if the first fit was large enough to be useful after splitting.

TESTING STRATEGY

As we were developing malloc, we included print statements at the start and end of each function and checkheap calls at the end of each function in order to determine what errors were causing the code to segfault and where these errors were occurring. These statements can only be reached by setting the "ourVerbose" flag equal to true.

We wrote our checkheap function to check that every block in our free lists was actually free, that every free block was in the appropriate free list, and that contiguous free blocks were properly coalesced. To do this, it checks the allocation bit of each block in the free lists, it checks through the corresponding free list for each free block in the heap, and it checks for contiguous free blocks (there should not be multiple free blocks in a row), respectively. In addition, it included the provided checks for the prologue and epilogue. 

By passing these checks, we confirmed that our implementation of the segregated lists worked. From there we tweaked the parameters for the segregated lists (number of lists, byte-range for each list) and code to improve performance. We deemed these checks to be sufficient because passing these checks and tweaking our parameters, we were able to get decent throughput and utilisation, even though we were not able to maximize them (in fact, we found a few instances where there were contiguous free blocks not coalesced as they should have been).

In addition to the checks we added, we split the provided prologue and epilogue checks to check whether the size and allocated bit were correct separately, since our code produced an invalid epilogue header early on in development.
